| **武汉大学国家网络安全学院教学实验报告**                                                                                                        |                    |          |            |      |
|-------------------------------------------------------------------------------------------------------------------------------------------------|--------------------|----------|------------|------|
| 课程名称                                                                                                                                        | 操作系统及安全设计 | 实验日期 | 2018.12.25 |      |
| 实验名称                                                                                                                                        | 进程               | 实验序号 | 7          |      |
| 姓 名                                                                                                                                           | 学 号              | 专业     | 年级-班    | 成绩 |
| 肖轩淦                                                                                                                                          | 2016301500327      | 信安     | 4          |      |
| 实验目的及实验内容 （本次实验所涉及并要求掌握的知识；实验内容；必要的原理分析）                                                                 |                    |          |            |      |
| 实验目的：                                                                                                                                      |                    |          |            |      |
| 实验环境及实验步骤 （本次实验所使用的器件、仪器设备等的情况；具体的实验步骤）                                                                   |                    |          |            |      |
| 实验环境： VMware Workstation 12 Pro Ubuntu 12.04.4 LTS 32位 实验步骤：                                                                         |                    |          |            |      |
| 实验过程分析 （实验分工，详细记录实验过程中发生的故障和问题，进行故障分析，说明故障排除的过程及方法。根据具体实验，记录、整理相应的数据表格等） |                    |          |            |      |
| [./media/image3.png](./media/image3.png) 答：（一）构造进程的关键技术：                                                                         |                    |          |            |      |
| 实验结果总结 （对实验结果进行分析，完成思考题目，总结实验成员每人的实验心得体会，并提出实验的改进意见）                                         |                    |          |            |      |
| 实验结果总结： 通过这次实验，对于进程及进程调度有了更深的了解。                                                                                 |                    |          |            |      |
| 教师评语                                                                                                                                        |                    |          |            |      |
| 全组评语：                                                                                                                                      |                    |          |            |      |
|                                                                                                                                                 |                    |          |            |      |
| 个人评语                                                                                                                                        |                    |          |            |      |
| 肖轩淦                                                                                                                                          |                    |          |            |      |
| 教师签名：                                                                                                                                      |                    |          |            |      |

![](media/258510962adead5d880b5a2aa52e9718.png)

实验内容：

![](media/d80b38b6abd68dec9cae72e1104a4439.png)

6.
实现一个能够实现分时进程调度和事件触发的进程调度系统，并对所实现的调度进行性能评测分析。

1.  阅读教材

2.  理解代码

3.  实现要求

4.  进程状态的保存（保存现场），包括哪些状态需要保存、何时进行保存、怎样保存。

5.  进程状态的恢复（恢复现场）

6.  进程表的引入

7.  进程栈和内核栈

8.  特权级的变换：ring0 和ring1之间的切换

（二）核心流程：

1、准备好进程体

![](media/2fd72c0affed7979b1df97c8a5f5e6b8.png)

1.  初始化GDT中的TSS和LDT两个描述符，并初始化TSS

![](media/66e7cb099d47df93e66ce3622b8cac65.png)

1.  准备进程表（PCB）

填充PCB中的相关信息，如pid、ldt selector即段、eip esp寄存器等

![](media/a9b395eed752eb7866071652202e7d99.png)

1.  完成跳转，实现ring0到ring1

将cpu交给p_proc_ready这个pcb指向的进程

![](media/c1b5da521e53bf2a170cf92b7eca6fbd.png)

![](media/be3e530489fe69eb1a56bb8a375b6ecc.png)

关键数据结构：

1.  先要将所有的寄存器保存到pcb

![](media/7dd4468b0055fdd5315783e17c6434cd.png)

1.  判断当前所处于的堆栈

若是当前处于用户堆栈则需要切换，若处于内核堆栈就不需要再进行切换

步骤：（以时钟中断调度为例）

1.  进入中断后，先保存全部寄存器

2.  判断当前所在堆栈，是否需要切换

3.  屏蔽当前中断

4.  置EOI位，开启中断，使cpu能接受其他中断。

5.  进行中断处理，如进行进程调度、计算进程占用cpu时间等等

6.  恢复接收当前中断

7.  中断处理结束，恢复寄存器，iret

![](media/0461381f688b151d11ae409e3c7c9a8a.png)

答：

1.  扩展单进程到多进程

添加一个进程体

![](media/ca8038c8f7355c9b90df27f5f2a0f3b4.png)

添加任务数组，方便我们对pcb进行初始化

![](media/4693936192fd8b05f1c80840cac6f7b0.png)

添加新加入的进程

![](media/005088e4ed8c3107cca42692d5420dff.png)

设置进程栈大小

![](media/098b73d0a3e5252f319af03acd842d40.png)

扩展初始化进程表，使之能为所有进程填充pcb

![](media/691d9092d7620f56cf08129d98b6fe37.png)

1.  扩展中断支持多进程

需要用一个宏定义来统一中断例程的入口，方便我们扩充。

![](media/0e24fed9021d1bfe0e93ee27f6f0703d.png)

![](media/43b754817447f5c9d0a71455b950c679.png)

![](media/f94bf88822c5cd1a702ee065b3dfabf3.png)

答：

1.  规定好系统调用的调用号及对应功能的功能号

系统调用号为0x90，功能号有两个，实现了两个功能

![](media/791c10ab889163cb9a0f1a3ac12dbcd6.png)

1.  编写入口程序

![](media/e82a49ff902cb3d9b1757cf52d2be5b0.png)

1.  初始化系统调用的中断门

![](media/79555f5accf490fb6e597cf679119892.png)

1.  编写int 90h中断例程

![](media/3c461b0a200664f927004324a4620ffc.png)

1.  编写系统调用功能程序表

![](media/31fdbed2b3dcda805dec61d83ad26ec5.png)

1.  编写功能程序

![](media/0c702f263cfd217c836039696baa031c.png)

1.  添加函数声明

2.  调用系统调用

![](media/bf0e05313ae0a397b4c537f5b7bdd60e.png)

![](media/cffa7107cfe281e8ff05fac430163c03.png)

在进入中断时，会对当前进程的堆栈进行存储；在退出中断时，会对当前进程的堆栈进行恢复。如下图所示。

![](media/9d7dae0d1ebe2051880f62121cb80342.png)

![](media/3394c9916db9f08e62cb13e6c4781f7b.png)

![](media/dc501d2b3e41462128f28fadaace6831.png)

在restart时进行堆栈的切换。

所以要实现进程的切换，只需要在中断中将p_proc_ready切换成目标进程即可。

以我实现的动态优先级时间片轮转调度算法为例，在中断中计时，并当时间片用完时，切换至下一个进程以实现进程调度。（下图红框所示，实现当前进程切换）

![](media/9a0adf48f9093fb671842fb90e0c7f12.png)

在中断退出时，restart函数中，恢复了p_proc_ready的堆栈，至此，实现了进程的调度。

6.
实现一个能够实现分时进程调度和事件触发的进程调度系统，并对所实现的调度进行性能评测分析。

使用说明：

Schedule/中有四个子文件夹，分别实现了四种调度算法：

Final-dyna_prio: 动态优先级时间片轮转调度算法

Final-fcfs: 先来先服务算法

Final-nomal: 静态优先级时间片轮转调度算法

Final-sfj: 短进程优先调度算法

（由于不同调度算法是通过宏定义来进行选择的，为了方便后续检查，每种调度算法均编译了一次，故有四个文件夹）

![](media/e64b47d4fb4d046cc0e01923160a3ceb.png)

接下来以final-dyna_prio为例，展示接下来的操作。

进入文件夹后，直接bochs即可启动

![](media/5dedd1e30606a0470bd8b31e0a4476fc.png)

启动后System_Idle_Process开始运行，等待我们下一步操作。

以下为功能说明：

仅接收按键0-9，各按键功能如下

0：清空屏幕

1-5号进程为实现生产者消费者模型

1：启动生产者进程；若生产者进程已经启动，再按下1则挂起生产者进程

2：启动消费者1进程；若消费者1进程已经启动，再按下2则将它挂起

3：启动消费者2进程；若消费者2进程已经启动，再按下3则将它挂起

4：启动消费者3进程；若消费者3进程已经启动，再按下4则将它挂起

5：启动消费者4进程；若消费者4进程已经启动，再按下5则将它挂起

6-9号进程为进行调度算法性能统计分析，在不同模式下其优先级及所需要的运行时间可能不同。

6：占用固定运行进程1

7：占用固定运行进程2

8：占用固定运行进程3

9：占用固定运行进程4

启动bochs后，按下12345678，启动8个进程

![](media/8caa73333bea2d59cda07953ecad6f28.png)

![](media/eb23210a251685bfec0b75151ff20c0f.png)

其中，Ready、HangOn、Finish代表各进程现在的状态：就绪、挂起或者结束。

在不同调度算法中，展示出的效果稍有不同，是由于各个调度算法的特性决定的

FCFS：（先来先服务不需要太多信息，故显示的较少）

![](media/dbb2e6df40a44e3dcffc4cd2ae93343a.png)

SFJ：（多出来的一列为剩余运行时间）

![](media/9b084c15a423b1a032aae39fafe13665.png)

Normal：

![](media/86fb5c0f11c3fe31fa99c3fa3f8269c2.png)

Dyna_Prio：

![](media/4ff824790b4385e21e53b17866c3a8aa.png)

代码说明：

由于实现的功能较多，代码也很多，故只选取有代表性的几个地方进行截图说明。

1.  生产者消费者的实现

这里使用

![](media/a280aecff58036d2a12a191592f8ef8f.png)

来保护缓冲区。

![](media/3cfeab86ce52f8bd45734580678a9851.png)

![](media/e7eb59f9e14f24fe365a62bcddd682c8.png)

1.  固定运行时间测试进程的实现

使用

![](media/e71831f904e44f3fe926a6f20171d3d0.png)

这两个数组进行占用cpu时间的计数，仅当进程在运行时才会计数。

![](media/1e8900bbeb712f6046cfd836522a0301.png)

1.  按键就绪挂起进程的实现

位于keyboard.c 键盘中断处理例程。

1-5号进程就绪/挂起直接将其加入/移除进程链表即可，6-9号进程因为会退出就绪时，需要重新填充pcb

![](media/559fe2112ceafa38e79c60b058579e10.png)

![](media/45d739b696b9d2a6f427d2883fe157d8.png)

1.  退出进程的系统调用实现：

![](media/0861331d70b7e087ddd4ea37402688b4.png)

![](media/73554c6e398ad7f4ec0963f154dc191e.png)

![](media/0bb2d2385d8480d7def646b555890681.png)

1.  FCFS调度：

![](media/fb422fee8fdabc7a3c9328690cd2c2f6.png)

1.  SFJ

![](media/8e1c5f30b41be169eafce9db459dab79.png)

1.  静态优先级时间片轮转调度

![](media/3dd0b3fb4def806301df84b054d235e4.png)

1.  动态优先级固定时间片轮转调度算法

![](media/fc9f402516c6294be93931c0772ff4d5.png)

![](media/53c2241772bd5c3f0f7023f0e39ff9f4.png)
